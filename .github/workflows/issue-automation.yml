name: Issue Management Automation
on:
  issues:
    types: [opened, labeled]

jobs:
  issue-triage:
    runs-on: ubuntu-latest
    steps:
      - name: Triage Issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const issueNumber = issue.number;
            
            // Define required labels
            const requiredLabels = [
              // Category Labels
              { name: 'bug', description: 'Something isn\'t working' },
              { name: 'enhancement', description: 'New feature or request' },
              { name: 'epic', description: 'Large feature requiring multiple sub-tasks' },
              { name: 'maintenance', description: 'Maintenance and housekeeping tasks' },
              // Priority Labels
              { name: 'priority-critical', description: 'Critical priority issue' },
              { name: 'priority-high', description: 'High priority issue' },
              { name: 'priority-medium', description: 'Medium priority issue' },
              { name: 'priority-low', description: 'Low priority issue' },
              // Status Labels
              { name: 'needs-triage', description: 'Needs to be reviewed by maintainers' },
              { name: 'needs-review', description: 'Awaiting review from maintainers' },
              { name: 'first-time-contributor', description: 'Issue created by first-time contributor' }
            ];
            
            // Create labels if they don't exist
            for (const label of requiredLabels) {
              try {
                await github.rest.issues.getLabel({
                  owner: repoOwner,
                  repo: repoName,
                  name: label.name
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: repoOwner,
                    repo: repoName,
                    name: label.name,
                    description: label.description
                  });
                } else {
                  throw error;
                }
              }
            }
            
            // Determine category labels from title
            const title = issue.title.toLowerCase();
            const body = issue.body ? issue.body.toLowerCase() : '';
            const categoryLabels = [];
            
            if (title.includes('bug')) categoryLabels.push('bug');
            if (title.includes('epic')) categoryLabels.push('epic');
            if (title.includes('maintenance')) categoryLabels.push('maintenance');
            
            // Determine priority label (highest priority wins)
            let priorityLabel = 'priority-medium'; // Default
            
            if (title.includes('critical') || title.includes('urgent') || title.includes('production') || title.includes('outage') ||
                body.includes('critical') || body.includes('urgent') || body.includes('production') || body.includes('outage')) {
              priorityLabel = 'priority-critical';
            } else if (title.includes('important') || title.includes('high') || title.includes('blocking') ||
                       body.includes('important') || body.includes('high') || body.includes('blocking')) {
              priorityLabel = 'priority-high';
            } else if (title.includes('low') || title.includes('nice-to-have') || title.includes('minor') ||
                       body.includes('low') || body.includes('nice-to-have') || body.includes('minor')) {
              priorityLabel = 'priority-low';
            }
            
            // Add all determined labels plus needs-triage
            const labelsToAdd = [...categoryLabels, priorityLabel, 'needs-triage'];
            
            await github.rest.issues.addLabels({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber,
              labels: labelsToAdd
            });

  task-breakdown:
    runs-on: ubuntu-latest
    needs: issue-triage
    if: contains(github.event.issue.labels.*.name, 'epic')
    steps:
      - name: Break Down Epic into Subtasks
        uses: actions/github-script@v7
        with:
          script: |
            const parentIssue = context.payload.issue;
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const parentNumber = parentIssue.number;
            const parentTitle = parentIssue.title;
            
            // Define subtask names
            const taskNames = [
              'Requirements Analysis',
              'Design and Architecture',
              'Implementation',
              'Testing and Documentation'
            ];
            
            // Create sub-issues
            const subIssues = [];
            for (let i = 0; i < taskNames.length; i++) {
              const taskNumber = i + 1;
              const subIssueTitle = `[SUBTASK] ${parentTitle} - Task ${taskNumber}: ${taskNames[i]}`;
              const subIssueBody = `Related to #${parentNumber}`;
              
              const createdSubIssue = await github.rest.issues.create({
                owner: repoOwner,
                repo: repoName,
                title: subIssueTitle,
                body: subIssueBody,
                labels: ['enhancement', 'needs-review']
              });
              
              subIssues.push(createdSubIssue.data);
            }
            
            // Update parent issue with epic tasks checklist
            const parentBody = parentIssue.body || '';
            const epicTasksSection = `## Epic Tasks\n\n${subIssues.map((sub, idx) => `- [ ] #${sub.number} (Task ${idx+1}: ${taskNames[idx]})`).join('\n')}`;
            
            const updatedParentBody = parentBody.includes('## Epic Tasks') 
              ? parentBody.replace(/## Epic Tasks[\s\S]*$/, epicTasksSection)
              : `${parentBody}\n\n${epicTasksSection}`;
            
            await github.rest.issues.update({
              owner: repoOwner,
              repo: repoName,
              issue_number: parentNumber,
              body: updatedParentBody
            });

  auto-response:
    runs-on: ubuntu-latest
    needs: issue-triage
    steps:
      - name: Send Auto-Response
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const issueNumber = issue.number;
            const author = issue.user.login;
            
            // Check if author is first-time contributor in this repo
            const issues = await github.rest.issues.listForRepo({
              owner: repoOwner,
              repo: repoName,
              creator: author,
              state: 'all'
            });
            const isFirstTimeContributor = issues.data.length === 1;
            
            // Get current issue labels
            const labels = issue.labels.map(l => l.name);
            
            // Add first-time-contributor label if needed
            if (isFirstTimeContributor) {
              await github.rest.issues.addLabels({
                owner: repoOwner,
                repo: repoName,
                issue_number: issueNumber,
                labels: ['first-time-contributor']
              });
            }
            
            // Generate response based on issue type
            let response = '';
            if (labels.includes('bug')) {
              response = `Thank you for reporting this bug! Please follow the **Bug Report Guidelines** to help us resolve it quickly:\n\n1. Provide detailed steps to reproduce the bug\n2. Include any relevant error messages or screenshots\n3. Specify your environment (OS, Node.js version, etc.)`;
            } else if (labels.includes('epic')) {
              response = `Thank you for submitting this epic feature request! Please review the **Feature Request Process**:\n\n1. This epic will be broken down into subtasks for implementation\n2. Each subtask will be reviewed and prioritized separately\n3. We'll provide updates on progress as we work through the tasks`;
            } else if (labels.includes('maintenance')) {
              response = `Thank you for submitting this maintenance request! Please follow the **Maintenance Guidelines**:\n\n1. Maintenance tasks are prioritized based on impact to the project\n2. We'll review the task and schedule it for the next available maintenance window\n3. You'll be notified once the task is completed`;
            } else {
              response = `Thank you for your submission! We'll review it shortly.`;
            }
            
            // Add welcome message for first-time contributors
            if (isFirstTimeContributor) {
              response = `Welcome to the project! This is your first issue in this repository. ${response}`;
            }
            
            // Post response comment
            await github.rest.issues.createComment({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber,
              body: response
            });
            
            // Set milestone for high/critical priority issues
            if (labels.includes('priority-high') || labels.includes('priority-critical')) {
              // Check if milestone exists, create if not
              try {
                await github.rest.issues.getMilestone({
                  owner: repoOwner,
                  repo: repoName,
                  milestone: 'v1.0.0'
                });
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.issues.createMilestone({
                    owner: repoOwner,
                    repo: repoName,
                    title: 'v1.0.0',
                    description: 'Version 1.0.0 milestone'
                  });
                } else {
                  throw error;
                }
              }
              
              // Get milestone ID
              const milestone = await github.rest.issues.getMilestone({
                owner: repoOwner,
                repo: repoName,
                milestone: 'v1.0.0'
              });
              
              // Assign milestone to issue
              await github.rest.issues.update({
                owner: repoOwner,
                repo: repoName,
                issue_number: issueNumber,
                milestone: milestone.data.number
              });
            }
            
            // Update status labels: remove needs-triage, add needs-review
            await github.rest.issues.removeLabel({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber,
              name: 'needs-triage'
            });
            
            await github.rest.issues.addLabels({
              owner: repoOwner,
              repo: repoName,
              issue_number: issueNumber,
              labels: ['needs-review']
            });